<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Notes · AoC2022</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AoC2022</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Notes</a><ul class="internal"><li><a class="tocitem" href="#Day-1"><span>Day 1</span></a></li><li><a class="tocitem" href="#Day-2"><span>Day 2</span></a></li><li><a class="tocitem" href="#Day-3"><span>Day 3</span></a></li><li><a class="tocitem" href="#Day-4"><span>Day 4</span></a></li><li><a class="tocitem" href="#Day-5"><span>Day 5</span></a></li><li><a class="tocitem" href="#Day-6"><span>Day 6</span></a></li><li><a class="tocitem" href="#Day-7"><span>Day 7</span></a></li><li><a class="tocitem" href="#Day-8"><span>Day 8</span></a></li><li><a class="tocitem" href="#Day-9"><span>Day 9</span></a></li><li><a class="tocitem" href="#Day-10"><span>Day 10</span></a></li><li><a class="tocitem" href="#Day-11"><span>Day 11</span></a></li><li><a class="tocitem" href="#Day-12"><span>Day 12</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Notes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Notes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakobnissen/AoC2022/blob/master/docs/src/notes.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Day-1"><a class="docs-heading-anchor" href="#Day-1">Day 1</a><a id="Day-1-1"></a><a class="docs-heading-anchor-permalink" href="#Day-1" title="Permalink"></a></h2><p>I sum each chunk during parsing, such that the input is parsed to a <code>Vector{&lt;:Integer}</code>. That may be considered cheating, but whatever. It&#39;s awkward to efficiently represent a <code>Vector{&lt;:Vector{&lt;:Integer}}</code>.</p><h2 id="Day-2"><a class="docs-heading-anchor" href="#Day-2">Day 2</a><a id="Day-2-1"></a><a class="docs-heading-anchor-permalink" href="#Day-2" title="Permalink"></a></h2><p>I parse my move and my opponent&#39;s move for both p1 and p2 at the same time, into a <code>Vector{NTuple{3, Choice}}</code>, <code>Choice</code> being an enum. To get the score for each round, I look up into a table. This can&#39;t vectorize, but I find playing with <code>mod</code> is too magical here.</p><h2 id="Day-3"><a class="docs-heading-anchor" href="#Day-3">Day 3</a><a id="Day-3-1"></a><a class="docs-heading-anchor-permalink" href="#Day-3" title="Permalink"></a></h2><p>I parse each line (a <code>RuckSack</code>) into two bitsets - one for each half. Since there are only 52 letters, 64-bit integers will do for the sets. The parser then emits <code>NTuple{3, RuckSack}</code>. The solution is straightforwardly expressed as bitwise operations + <code>trailing_zeros</code> (which maps onto a tzcnt instruction). This is extremely fast.</p><h2 id="Day-4"><a class="docs-heading-anchor" href="#Day-4">Day 4</a><a id="Day-4-1"></a><a class="docs-heading-anchor-permalink" href="#Day-4" title="Permalink"></a></h2><p>I parse each line to <code>NTuple{2, UnitRange}</code>. To improve parsing speed, I implement my own <code>split_once</code>, which really ought to be in <code>Base</code> Julia. Computing whether ranges overlap can easily be done only looking at the endpoints of each range. The implementation is generic.</p><h2 id="Day-5"><a class="docs-heading-anchor" href="#Day-5">Day 5</a><a id="Day-5-1"></a><a class="docs-heading-anchor-permalink" href="#Day-5" title="Permalink"></a></h2><p>Parsing absolutely sucks for this, especially because the problem does not specify that each tower is listed from 1:N. My solution assumes the towers can have arbitrary integer names. Regex to the rescue. The tower is parsed into <code>Dict{&lt;:Integer, &lt;:Vector}</code>, they keys being the name of the tower. Each vector is bottom-up, so the top can be added and removed with <code>push!</code> and <code>pop!</code>. When parsing moves, I use a regex, then parsed into an <code>NTuple{3, Integer}</code>. To move in part 1, I <code>append!</code> to the target and truncate the source, then reverse the appended bit. For part 2, I simply don&#39;t reverse. </p><h2 id="Day-6"><a class="docs-heading-anchor" href="#Day-6">Day 6</a><a id="Day-6-1"></a><a class="docs-heading-anchor-permalink" href="#Day-6" title="Permalink"></a></h2><p>Parsing this is trivial. I simply strip the input line and check it&#39;s only composed of <code>&#39;a&#39;:&#39;z&#39;</code>, then put it into a struct. For each part, I keep a length 26 vector with one element for each possible letter. In it, I store the last index where the given letter was seen. We keep track of the remaining letters needed before N distinct letters is seen. For each letter, we look up in the vector where it was last seen, and update <code>remaining</code> accordingly. If <code>remaining</code> reaches 0, it returns. Hence, the cost does not scale with N, but is linear for each letter examined.</p><h2 id="Day-7"><a class="docs-heading-anchor" href="#Day-7">Day 7</a><a id="Day-7-1"></a><a class="docs-heading-anchor-permalink" href="#Day-7" title="Permalink"></a></h2><p>Parsing is tough here. I parse into a <code>Directory</code> structure, which contain a name, a link to a parent, a vector of subdirectories, and the sum of sizes of files in that dir. A recursive function can then easily and effectively get the total size of each directory.</p><h2 id="Day-8"><a class="docs-heading-anchor" href="#Day-8">Day 8</a><a id="Day-8-1"></a><a class="docs-heading-anchor-permalink" href="#Day-8" title="Permalink"></a></h2><p>Parse to <code>Matrix{&lt;:Integer}</code>. Every solution can be computed by taking views of a single column or row into the matrix (reversed and not), and keeping a scratch vector for the computation. In other words, the computation of each col/row vector is independent. These view needs to be takes for every row and column, in both direction of the matrix, and then accumulated into a destination matrix. The solution is similar to mapreduce:</p><ul><li><code>f</code> is the function that, given a vector view and a scratch buffer, fills in the vector view</li><li><code>op</code> is the operation that accumulate into the destination vector: <code>|</code> for p1, and <code>*</code> for p1.</li><li>The iterable is the rows/cols of the destination vector and input vector.</li></ul><p>For part 2, I use a trick similar to day 6, keeping a list of the last index where a tree of a given height is. This makes the solution for this day scale linearly with the number of elements in the matrix.</p><h2 id="Day-9"><a class="docs-heading-anchor" href="#Day-9">Day 9</a><a id="Day-9-1"></a><a class="docs-heading-anchor-permalink" href="#Day-9" title="Permalink"></a></h2><p>Straightforward parsing into <code>Vector{&lt;:Tuple{Direction, Integer}}</code>, where <code>Direction</code> is an enum. The trick is that the tail always moves <code>(sign(dy), sign(dx))</code> relative to the head, unless it&#39;ll end up on top of the head. Visited positions is kept track of in a <code>Set</code>.</p><p>For part 2, whenever a knot in the tail didn&#39;t move, the rest of the rope can be skipped that iteration.</p><p>As another optimisation, the last position of the tail can be kept track of in a variable. Only add it to the <code>Set</code> if it did move, to cut down on the number of set operations, which are slow.</p><h2 id="Day-10"><a class="docs-heading-anchor" href="#Day-10">Day 10</a><a id="Day-10-1"></a><a class="docs-heading-anchor-permalink" href="#Day-10" title="Permalink"></a></h2><p>I parse into a <code>Vector{&lt;:Union{Nothing, &lt;:Integer}}</code>. The processor can be simulated very efficiency by directly looping over each cycle. The screen is <code>Vector{Bool}</code>. I make a function <code>avance</code>, which given a <code>State</code> struct advances exactly <code>N</code> cycles, returning a new <code>State</code>. This means that during the inntermost loop, there is no need to keep track of whether the cycle number is one of the threshold numbers.</p><h2 id="Day-11"><a class="docs-heading-anchor" href="#Day-11">Day 11</a><a id="Day-11-1"></a><a class="docs-heading-anchor-permalink" href="#Day-11" title="Permalink"></a></h2><p>This one was tough to parse and optimise. Parsing is done with lots of regex, and assuming the lines are in the same order all the time. Seems inefficient, but is quite fast.</p><p>Each monkey is modeled as a <code>mutable struct</code>, containing its own items. This allows you to loop over the items of each monkey directly. The monkey&#39;s operation is stored in a custom <code>Operation</code> struct which can only square, multiply and add. This prevents dynamic dispatch, trading away generality.</p><p>Instead of computing modulo directly, compute a <code>MultiplicativeInverse</code> for each monkey, and for the product of the monkeys&#39; divisors. This speeds up modulo operations.</p><p>Because <code>push!</code> is slow in Julia, each monkey&#39;s item vector is resized to be able to hold all items, and the actual number of items in the array is kept track of by an integer stored in the monkey. This prevents calling into C to resize any arrays.</p><p>A total of ~750,000 items are examined, and each examination is necessarily serial and takes multiple steps. To get below 1 ms, each item need to take only ~1 ns.</p><p>In order to get this down below 1 ms, it will be necessary to exploit that each item follows a cycle. Compute the cycle for each item.</p><h2 id="Day-12"><a class="docs-heading-anchor" href="#Day-12">Day 12</a><a id="Day-12-1"></a><a class="docs-heading-anchor-permalink" href="#Day-12" title="Permalink"></a></h2><p>Parse into <code>Matrix{&lt;:Integer}</code>, as well as <code>CartesianIndex</code> for start and end points. Straightforward dynamic programming approach similar to Smith-Waterman as taught to me in bioinformatics class: It takes 0 steps to reach the starting point. The neighbors of all points reachable in N steps are reachable in N+1 steps. Start from 0 until the end point is reached.</p><p>The queue of upcoming points to process is stored in a <code>Vector</code>. This creates some duplicate work, but it&#39;s much faster than using <code>Set</code>s, as each point is cheap to compute.</p><p>Return as soon as the end point is found.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 12 December 2022 19:26">Monday 12 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
